#!/usr/bin/env python3
"""
Doxygen MCP Server

A comprehensive Model Context Protocol server that provides full access to Doxygen's 
documentation generation capabilities. This server exposes Doxygen's complete feature 
set through a clean MCP interface, enabling AI assistants to generate, configure, 
and manage documentation for any supported programming language.

Supported Languages:
- Primary: C, C++, Python, PHP
- Extended: Java, C#, JavaScript, Objective-C, Fortran, VHDL
- Additional: Batch, PowerShell, Bash, Perl, Go (through extension mapping)

Key Features:
- Project initialization and configuration management
- Multi-format output generation (HTML, PDF, LaTeX, XML, etc.)
- Advanced diagram generation (UML, call graphs, inheritance diagrams)
- Documentation coverage analysis and validation
- Cross-referencing and link generation
- Custom theme and layout support
"""

import asyncio
import json
import logging
import os
import subprocess
import tempfile
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Union
import shutil
import re

# MCP server imports
from mcp.server import Server
from mcp.types import (
    Resource,
    Tool,
    TextContent,
    ImageContent,
    EmbeddedResource,
    LoggingLevel
)
from pydantic import BaseModel

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("doxygen-mcp")

class DoxygenConfig(BaseModel):
    """Represents a Doxygen configuration with all major options"""
    
    # Project settings
    project_name: str = "My Project"
    project_number: str = ""
    project_brief: str = ""
    project_logo: str = ""
    output_directory: str = "./docs"
    
    # Input settings
    input_paths: List[str] = ["."]
    file_patterns: List[str] = ["*.c", "*.cpp", "*.h", "*.hpp", "*.py", "*.php"]
    recursive: bool = True
    exclude_patterns: List[str] = []
    
    # Language optimization
    optimize_output_for_c: bool = False
    optimize_output_java: bool = False
    optimize_for_fortran: bool = False
    optimize_output_vhdl: bool = False
    
    # Output formats
    generate_html: bool = True
    generate_latex: bool = False
    generate_rtf: bool = False
    generate_man: bool = False
    generate_xml: bool = False
    generate_docbook: bool = False
    
    # Documentation extraction
    extract_all: bool = True
    extract_private: bool = False
    extract_static: bool = True
    extract_local_classes: bool = True
    
    # Diagram generation
    have_dot: bool = True
    class_graph: bool = True
    collaboration_graph: bool = True
    call_graph: bool = False
    caller_graph: bool = False
    include_graph: bool = True
    included_by_graph: bool = True
    
    # Advanced features
    source_browser: bool = True
    inline_sources: bool = False
    strip_code_comments: bool = True
    referenced_by_relation: bool = True
    references_relation: bool = True
    
    def to_doxyfile(self) -> str:
        """Convert configuration to Doxyfile format"""
        lines = [
            f"# Doxyfile generated by Doxygen MCP Server",
            f"",
            f"# Project related configuration options",
            f"PROJECT_NAME           = \"{self.project_name}\"",
            f"PROJECT_NUMBER         = \"{self.project_number}\"",
            f"PROJECT_BRIEF          = \"{self.project_brief}\"",
            f"PROJECT_LOGO           = \"{self.project_logo}\"",
            f"OUTPUT_DIRECTORY       = \"{self.output_directory}\"",
            f"",
            f"# Build related configuration options",
            f"EXTRACT_ALL            = {'YES' if self.extract_all else 'NO'}",
            f"EXTRACT_PRIVATE        = {'YES' if self.extract_private else 'NO'}",
            f"EXTRACT_STATIC         = {'YES' if self.extract_static else 'NO'}",
            f"EXTRACT_LOCAL_CLASSES  = {'YES' if self.extract_local_classes else 'NO'}",
            f"",
            f"# Input related configuration options",
            f"INPUT                  = {' '.join(self.input_paths)}",
            f"FILE_PATTERNS          = {' '.join(self.file_patterns)}",
            f"RECURSIVE              = {'YES' if self.recursive else 'NO'}",
        ]
        
        if self.exclude_patterns:
            lines.append(f"EXCLUDE_PATTERNS       = {' '.join(self.exclude_patterns)}")
        
        lines.extend([
            f"",
            f"# Language optimization",
            f"OPTIMIZE_OUTPUT_FOR_C  = {'YES' if self.optimize_output_for_c else 'NO'}",
            f"OPTIMIZE_OUTPUT_JAVA   = {'YES' if self.optimize_output_java else 'NO'}",
            f"OPTIMIZE_FOR_FORTRAN   = {'YES' if self.optimize_for_fortran else 'NO'}",
            f"OPTIMIZE_OUTPUT_VHDL   = {'YES' if self.optimize_output_vhdl else 'NO'}",
            f"",
            f"# Output format configuration",
            f"GENERATE_HTML          = {'YES' if self.generate_html else 'NO'}",
            f"GENERATE_LATEX         = {'YES' if self.generate_latex else 'NO'}",
            f"GENERATE_RTF           = {'YES' if self.generate_rtf else 'NO'}",
            f"GENERATE_MAN           = {'YES' if self.generate_man else 'NO'}",
            f"GENERATE_XML           = {'YES' if self.generate_xml else 'NO'}",
            f"GENERATE_DOCBOOK       = {'YES' if self.generate_docbook else 'NO'}",
            f"",
            f"# Diagram generation",
            f"HAVE_DOT               = {'YES' if self.have_dot else 'NO'}",
            f"CLASS_GRAPH            = {'YES' if self.class_graph else 'NO'}",
            f"COLLABORATION_GRAPH    = {'YES' if self.collaboration_graph else 'NO'}",
            f"CALL_GRAPH             = {'YES' if self.call_graph else 'NO'}",
            f"CALLER_GRAPH           = {'YES' if self.caller_graph else 'NO'}",
            f"INCLUDE_GRAPH          = {'YES' if self.include_graph else 'NO'}",
            f"INCLUDED_BY_GRAPH      = {'YES' if self.included_by_graph else 'NO'}",
            f"",
            f"# Source browsing",
            f"SOURCE_BROWSER         = {'YES' if self.source_browser else 'NO'}",
            f"INLINE_SOURCES         = {'YES' if self.inline_sources else 'NO'}",
            f"STRIP_CODE_COMMENTS    = {'YES' if self.strip_code_comments else 'NO'}",
            f"REFERENCED_BY_RELATION = {'YES' if self.referenced_by_relation else 'NO'}",
            f"REFERENCES_RELATION    = {'YES' if self.references_relation else 'NO'}",
        ])
        
        return "\n".join(lines)


class DoxygenServer:
    """Core Doxygen server implementation"""
    
    def __init__(self):
        self.server = Server("doxygen-mcp")
        self.projects: Dict[str, DoxygenConfig] = {}
        self.setup_handlers()
    
    def setup_handlers(self):
        """Set up all MCP tool handlers"""
        
        # Project Management Tools
        @self.server.list_tools()
        async def handle_list_tools() -> List[Tool]:
            """List all available Doxygen tools"""
            return [
                # Project Management
                Tool(
                    name="create_doxygen_project",
                    description="Initialize a new Doxygen documentation project with configuration",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "project_name": {"type": "string", "description": "Name of the project"},
                            "project_path": {"type": "string", "description": "Path to the project directory"},
                            "language": {"type": "string", "enum": ["c", "cpp", "python", "php", "java", "csharp", "javascript", "mixed"], "description": "Primary programming language"},
                            "include_subdirs": {"type": "boolean", "default": True, "description": "Scan subdirectories recursively"},
                            "extract_private": {"type": "boolean", "default": False, "description": "Include private members in documentation"}
                        },
                        "required": ["project_name", "project_path"]
                    }
                ),
                
                Tool(
                    name="generate_documentation",
                    description="Generate documentation from source code using Doxygen",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "project_path": {"type": "string", "description": "Path to the project directory"},
                            "output_format": {"type": "string", "enum": ["html", "latex", "xml", "all"], "default": "html", "description": "Output format"},
                            "clean_output": {"type": "boolean", "default": True, "description": "Clean output directory before generation"},
                            "verbose": {"type": "boolean", "default": False, "description": "Enable verbose output"}
                        },
                        "required": ["project_path"]
                    }
                ),
                
                Tool(
                    name="scan_project",
                    description="Analyze project structure and identify documentation opportunities",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "project_path": {"type": "string", "description": "Path to scan"},
                            "language_filter": {"type": "array", "items": {"type": "string"}, "description": "File extensions to include"},
                            "exclude_patterns": {"type": "array", "items": {"type": "string"}, "description": "Patterns to exclude from scanning"}
                        },
                        "required": ["project_path"]
                    }
                ),
                
                Tool(
                    name="validate_documentation",
                    description="Check for documentation warnings, missing docs, and coverage analysis",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "project_path": {"type": "string", "description": "Path to the project directory"},
                            "check_coverage": {"type": "boolean", "default": True, "description": "Analyze documentation coverage"},
                            "warn_undocumented": {"type": "boolean", "default": True, "description": "Report undocumented members"},
                            "output_format": {"type": "string", "enum": ["text", "json"], "default": "text", "description": "Output format for results"}
                        },
                        "required": ["project_path"]
                    }
                ),
                
                Tool(
                    name="create_doxyfile",
                    description="Generate a Doxyfile configuration with specified settings",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "output_path": {"type": "string", "description": "Where to save the Doxyfile"},
                            "template": {"type": "string", "enum": ["minimal", "standard", "comprehensive"], "default": "standard", "description": "Configuration template"},
                            "project_settings": {"type": "object", "description": "Project-specific settings"},
                            "language_optimizations": {"type": "array", "items": {"type": "string"}, "description": "Languages to optimize for"}
                        },
                        "required": ["output_path"]
                    }
                ),
                
                Tool(
                    name="check_doxygen_install",
                    description="Verify Doxygen installation and capabilities",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "check_dot": {"type": "boolean", "default": True, "description": "Check for Graphviz dot tool"},
                            "check_latex": {"type": "boolean", "default": True, "description": "Check for LaTeX installation"},
                            "detailed": {"type": "boolean", "default": False, "description": "Provide detailed version information"}
                        }
                    }
                ),
                
                Tool(
                    name="suggest_file_patterns",
                    description="Suggest appropriate file patterns for a project",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "project_path": {"type": "string", "description": "Path to analyze"},
                            "primary_language": {"type": "string", "description": "Primary programming language"},
                            "include_tests": {"type": "boolean", "default": False, "description": "Include test file patterns"},
                            "include_examples": {"type": "boolean", "default": True, "description": "Include example file patterns"}
                        },
                        "required": ["project_path"]
                    }
                )
            ]
        
        @self.server.call_tool()
        async def handle_call_tool(name: str, arguments: Dict[str, Any]) -> Sequence[TextContent]:
            """Handle tool calls"""
            try:
                if name == "create_doxygen_project":
                    return await self._create_project(arguments)
                elif name == "generate_documentation":
                    return await self._generate_documentation(arguments)
                elif name == "scan_project":
                    return await self._scan_project(arguments)
                elif name == "validate_documentation":
                    return await self._validate_documentation(arguments)
                elif name == "create_doxyfile":
                    return await self._create_doxyfile(arguments)
                elif name == "check_doxygen_install":
                    return await self._check_doxygen_install(arguments)
                elif name == "suggest_file_patterns":
                    return await self._suggest_file_patterns(arguments)
                else:
                    return [TextContent(type="text", text=f"Unknown tool: {name}")]
            except Exception as e:
                logger.error(f"Error calling tool {name}: {str(e)}")
                return [TextContent(type="text", text=f"Error: {str(e)}")]
    
    # Tool Implementation Methods (simplified for MVP)
    
    async def _create_project(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        """Create a new Doxygen project"""
        project_name = args["project_name"]
        project_path = Path(args["project_path"])
        language = args.get("language", "mixed")
        include_subdirs = args.get("include_subdirs", True)
        extract_private = args.get("extract_private", False)
        
        try:
            # Create project directory if it doesn't exist
            project_path.mkdir(parents=True, exist_ok=True)
            
            # Create configuration based on language
            config = DoxygenConfig(
                project_name=project_name,
                output_directory=str(project_path / "docs"),
                input_paths=[str(project_path)],
                recursive=include_subdirs,
                extract_private=extract_private
            )
            
            # Language-specific optimizations
            if language == "c":
                config.optimize_output_for_c = True
                config.file_patterns = ["*.c", "*.h"]
            elif language == "cpp":
                config.file_patterns = ["*.cpp", "*.hpp", "*.cc", "*.hh", "*.cxx", "*.hxx"]
            elif language == "python":
                config.optimize_output_java = True  # Python uses Java-style optimization
                config.file_patterns = ["*.py"]
            elif language == "php":
                config.file_patterns = ["*.php", "*.php3", "*.inc"]
            elif language == "java":
                config.optimize_output_java = True
                config.file_patterns = ["*.java"]
            elif language == "csharp":
                config.file_patterns = ["*.cs"]
            elif language == "javascript":
                config.file_patterns = ["*.js", "*.jsx", "*.ts", "*.tsx"]
            
            # Save configuration
            doxyfile_path = project_path / "Doxyfile"
            with open(doxyfile_path, 'w', encoding='utf-8') as f:
                f.write(config.to_doxyfile())
            
            # Store project configuration
            self.projects[str(project_path)] = config
            
            result = f"""âœ… Doxygen project '{project_name}' created successfully!

ðŸ“ Project Path: {project_path}
ðŸ”§ Language: {language}
ðŸ“„ Configuration: {doxyfile_path}

Configuration Summary:
- Output Directory: {config.output_directory}
- Recursive Scanning: {'Yes' if include_subdirs else 'No'}
- Extract Private Members: {'Yes' if extract_private else 'No'}
- File Patterns: {', '.join(config.file_patterns)}

Next Steps:
1. Review and customize the Doxyfile if needed
2. Add documentation comments to your source code
3. Run 'generate_documentation' to create docs

The project is ready for documentation generation!"""
            
            return [TextContent(type="text", text=result)]
            
        except Exception as e:
            return [TextContent(type="text", text=f"âŒ Failed to create project: {str(e)}")]
    
    async def _generate_documentation(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        """Generate documentation using Doxygen"""
        project_path = Path(args["project_path"])
        output_format = args.get("output_format", "html")
        clean_output = args.get("clean_output", True)
        verbose = args.get("verbose", False)
        
        doxyfile_path = project_path / "Doxyfile"
        if not doxyfile_path.exists():
            return [TextContent(type="text", text="âŒ No Doxyfile found. Create a project first using 'create_doxygen_project'.")]
        
        try:
            # Check if doxygen is available
            result = subprocess.run(["doxygen", "--version"], capture_output=True, text=True)
            if result.returncode != 0:
                return [TextContent(type="text", text="âŒ Doxygen not found. Please install Doxygen first.")]
            
            doxygen_version = result.stdout.strip()
            
            # Run Doxygen
            cmd = ["doxygen", str(doxyfile_path)]
            result = subprocess.run(
                cmd, 
                cwd=project_path, 
                capture_output=True, 
                text=True
            )
            
            if result.returncode == 0:
                # Parse output for statistics
                output_lines = result.stderr.split('\n')
                warnings = [line for line in output_lines if 'warning' in line.lower()]
                
                result_text = f"""âœ… Documentation generated successfully!

ðŸ”§ Doxygen Version: {doxygen_version}
ðŸ“ Project: {project_path}
ðŸ“Š Warnings: {len(warnings)}

Generated Files:
ðŸ“„ HTML: {project_path / 'docs' / 'html' / 'index.html'}

"""
                
                if warnings and verbose:
                    result_text += f"\nâš ï¸ Warnings:\n" + "\n".join(warnings[:10])
                    if len(warnings) > 10:
                        result_text += f"\n... and {len(warnings) - 10} more warnings"
                
                if not verbose and warnings:
                    result_text += f"\nðŸ’¡ Use verbose=true to see detailed warnings"
                
                return [TextContent(type="text", text=result_text)]
            else:
                error_output = result.stderr or result.stdout
                return [TextContent(type="text", text=f"âŒ Documentation generation failed:\n{error_output}")]
                
        except Exception as e:
            return [TextContent(type="text", text=f"âŒ Error generating documentation: {str(e)}")]
    
    async def _scan_project(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        """Scan project structure and identify files"""
        project_path = Path(args["project_path"])
        
        if not project_path.exists():
            return [TextContent(type="text", text=f"âŒ Project path does not exist: {project_path}")]
        
        try:
            # Count files by extension
            extensions = {}
            total_files = 0
            
            for file_path in project_path.rglob("*"):
                if file_path.is_file():
                    ext = file_path.suffix.lower()
                    if ext:
                        extensions[ext] = extensions.get(ext, 0) + 1
                        total_files += 1
            
            # Sort by frequency
            sorted_extensions = sorted(extensions.items(), key=lambda x: x[1], reverse=True)
            
            result_text = f"""ðŸ“ Project Scan Results for: {project_path}
ðŸ“Š Total Files Found: {total_files}

ðŸ“‹ Files by Type:
"""
            
            for ext, count in sorted_extensions[:15]:  # Show top 15 extensions
                result_text += f"  ðŸ“„ {ext}: {count} files\n"
            
            return [TextContent(type="text", text=result_text)]
            
        except Exception as e:
            return [TextContent(type="text", text=f"âŒ Error scanning project: {str(e)}")]
    
    # Simplified implementations for other methods
    async def _validate_documentation(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        return [TextContent(type="text", text="ðŸš§ Documentation validation coming soon!")]
    
    async def _create_doxyfile(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        return [TextContent(type="text", text="ðŸš§ Create Doxyfile functionality coming soon!")]
    
    async def _check_doxygen_install(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        try:
            result = subprocess.run(["doxygen", "--version"], capture_output=True, text=True)
            if result.returncode == 0:
                version = result.stdout.strip()
                return [TextContent(type="text", text=f"âœ… Doxygen {version} is installed and working!")]
            else:
                return [TextContent(type="text", text="âŒ Doxygen is not working properly")]
        except FileNotFoundError:
            return [TextContent(type="text", text="âŒ Doxygen is not installed")]
    
    async def _suggest_file_patterns(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        return [TextContent(type="text", text="ðŸš§ File pattern suggestions coming soon!")]


async def main():
    """Main entry point for the Doxygen MCP server"""
    doxygen_server = DoxygenServer()
    
    # Run the server using stdio
    from mcp.server.stdio import stdio_server
    
    async with stdio_server() as (read_stream, write_stream):
        await doxygen_server.server.run(
            read_stream,
            write_stream,
            doxygen_server.server.create_initialization_options()
        )

if __name__ == "__main__":
    asyncio.run(main())
